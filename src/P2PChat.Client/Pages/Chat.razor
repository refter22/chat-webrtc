@page "/"
@using P2PChat.Client.Services
@using P2PChat.Shared.Models
@using Microsoft.Extensions.Logging
@using Microsoft.AspNetCore.Components.Forms
@inject WebRTCService WebRTCService
@inject SignalRService SignalRService
@inject ILogger<Chat> Logger

<div class="chat-container">
    @if (!SignalRService.IsConnected)
    {
        <div class="connecting">
            <p>Connecting to server...</p>
        </div>
    }
    else if (string.IsNullOrEmpty(selectedUserId))
    {
        <div class="user-list">
            <h3>Connected Users (@(connectedUsers.Where(u => u != SignalRService.UserId).Count()))</h3>
            @if (!connectedUsers.Any(u => u != SignalRService.UserId))
            {
                <p>Waiting for other users to connect...</p>
            }
            else
            {
                <div class="users">
                    @foreach (var user in connectedUsers.Where(u => u != SignalRService.UserId))
                    {
                        <button class="user-item" @onclick="() => HandleUserClick(user)">
                            Chat with @user
                        </button>
                    }
                </div>
            }
        </div>
    }
    else
    {
        <div class="chat">
            <div class="messages">
                @foreach (var message in messages)
                {
                    <div class="message @(message.IsFromMe ? "sent" : "received")">
                        @if (message.IsFile)
                        {
                            <div class="file-message">
                                <span class="file-icon">ðŸ“Ž</span>
                                <span class="file-name">@message.FileName</span>
                                @if (message.IsReceiving)
                                {
                                    <div class="progress">
                                        <div class="progress-bar" style="width: @(message.Progress)%">
                                            @message.Progress%
                                        </div>
                                    </div>
                                }
                                @if (message.FileUrl != null)
                                {
                                    <a href="@message.FileUrl" download="@message.FileName">Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ</a>
                                }
                            </div>
                        }
                        else
                        {
                            @message.Text
                        }
                    </div>
                }
            </div>
            <div class="input-area">
                <InputFile OnChange="HandleFileSelected" class="file-input" />
                <input @bind="newMessage" @bind:event="oninput" @onkeyup="HandleKeyPress" />
                <button @onclick="SendMessage">Send</button>
            </div>
        </div>
    }
</div>

@code {
    private HashSet<string> connectedUsers = new();
    private string? selectedUserId;
    private List<ChatMessage> messages = new();
    private string newMessage = "";
    private bool isWebRTCConnected;
    private List<string?> currentFileChunks = new();
    private int expectedChunks = 0;

    protected override async Task OnInitializedAsync()
    {
        SignalRService.OnConnected += HandleConnected;
        SignalRService.OnUserConnected += HandleUserConnected;
        SignalRService.OnSignalReceived += HandleSignalReceived;
        WebRTCService.OnMessageReceived += HandleMessageReceived;
        WebRTCService.OnConnectionEstablished += HandleWebRTCConnected;
        WebRTCService.OnFileReceiveStarted += HandleFileReceiveStarted;
        WebRTCService.OnFileChunkReceived += HandleFileChunk;
        WebRTCService.OnFileReceiveCompleted += HandleFileReceiveCompleted;

        try
        {
            await SignalRService.StartAsync();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Failed to connect: {ex.Message}");
        }
    }

    private void HandleConnected(string userId)
    {
        connectedUsers.Add(userId);
        StateHasChanged();
    }

    private void HandleUserConnected(string userId)
    {
        if (!connectedUsers.Contains(userId))
        {
            connectedUsers.Add(userId);
            StateHasChanged();
        }
    }

    private async Task HandleUserClick(string userId)
    {
        try
        {
            selectedUserId = userId;

            if (WebRTCService.IsConnected && WebRTCService.TargetUserId != userId)
            {
                await WebRTCService.DisposeAsync();
            }

            if (!WebRTCService.IsConnected || WebRTCService.TargetUserId != userId)
            {
                messages.Clear();
                isWebRTCConnected = false;
                await WebRTCService.StartConnection(userId, true);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start chat with user: {UserId}", userId);
            selectedUserId = null;
        }
    }

    private void HandleSignalReceived(SignalMessage signal)
    {
        Console.WriteLine($"Received signal: {signal.Type}");
    }

    private void HandleMessageReceived(string message)
    {
        messages.Add(new ChatMessage { Text = message, IsFromMe = false });
        StateHasChanged();
    }

    private void HandleWebRTCConnected()
    {
        isWebRTCConnected = true;
        StateHasChanged();
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(newMessage)) return;

        if (!isWebRTCConnected)
        {
            Logger.LogWarning("Cannot send message: WebRTC not connected");
            return;
        }

        try
        {
            await WebRTCService.SendMessageAsync(newMessage);
            messages.Add(new ChatMessage { Text = newMessage, IsFromMe = true });
            newMessage = "";
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to send message");
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SendMessage();
        }
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            if (file == null) return;

            var message = new ChatMessage
            {
                IsFromMe = true,
                IsFile = true,
                FileName = file.Name,
                Progress = 0
            };
            messages.Add(message);

            await WebRTCService.SendFileAsync(file);

            var fileStream = file.OpenReadStream(maxAllowedSize: 10485760); // 10MB
            var ms = new MemoryStream();
            await fileStream.CopyToAsync(ms);
            var base64 = Convert.ToBase64String(ms.ToArray());
            message.FileUrl = $"data:{file.ContentType};base64,{base64}";

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error sending file");
        }
    }

    private ChatMessage? currentFileMessage;

    private void HandleFileReceiveStarted(FileMetadata metadata)
    {
        try
        {
            Logger.LogInformation($"File receive started: {metadata.Name}, size: {metadata.Size}");

            currentFileMessage = new ChatMessage
            {
                IsFromMe = false,
                IsFile = true,
                FileName = metadata.Name,
                IsReceiving = true,
                Progress = 0,
                FileSize = metadata.Size,
                FileMimeType = metadata.MimeType
            };
            messages.Add(currentFileMessage);
            currentFileChunks.Clear();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting file receive");
        }
    }

    private void HandleFileChunk(FileChunk chunk)
    {
        try
        {
            if (currentFileMessage == null) return;

            while (currentFileChunks.Count <= chunk.Index)
            {
                currentFileChunks.Add(null);
            }
            currentFileChunks[chunk.Index] = chunk.Data;
            expectedChunks = chunk.Total;

            var progress = (double)currentFileChunks.Count(c => c != null) / expectedChunks * 100;
            currentFileMessage.Progress = (int)progress;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error receiving file chunk");
        }
    }

    private void HandleFileReceiveCompleted()
    {
        try
        {
            if (currentFileMessage == null) return;

            var base64Data = string.Concat(currentFileChunks.Where(c => c != null));

            currentFileMessage.FileUrl = $"data:{currentFileMessage.FileMimeType};base64,{base64Data}";
            currentFileMessage.IsReceiving = false;

            currentFileChunks.Clear();
            currentFileMessage = null;

            StateHasChanged();
            Logger.LogInformation("File processing completed successfully");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during file processing");
        }
    }

    public void Dispose()
    {
        WebRTCService.OnMessageReceived -= HandleMessageReceived;
        WebRTCService.OnConnectionEstablished -= HandleWebRTCConnected;
        SignalRService.OnConnected -= HandleConnected;
        SignalRService.OnUserConnected -= HandleUserConnected;
        SignalRService.OnSignalReceived -= HandleSignalReceived;
        WebRTCService.OnFileReceiveStarted -= HandleFileReceiveStarted;
        WebRTCService.OnFileChunkReceived -= HandleFileChunk;
        WebRTCService.OnFileReceiveCompleted -= HandleFileReceiveCompleted;
        currentFileChunks.Clear();
    }

    private class ChatMessage
    {
        public string Text { get; set; } = "";
        public bool IsFromMe { get; set; }
        public bool IsFile { get; set; }
        public string? FileName { get; set; }
        public string? FileUrl { get; set; }
        public bool IsReceiving { get; set; }
        public int Progress { get; set; }
        public long FileSize { get; set; }
        public string FileMimeType { get; set; } = "";
    }
}